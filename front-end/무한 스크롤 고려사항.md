<!-- TOC -->
* [1. 무한 스크롤](#1-무한-스크롤)
* [2. 페이지와 컨텐츠 구성 예시](#2-페이지와-컨텐츠-구성-예시)
* [3. 페이징과 정렬 기준](#3-페이징과-정렬-기준)
* [4. 스크롤 위치 계산을 위해 컨텐츠는 고정 높이를 가져아 합니다.](#4-스크롤-위치-계산을-위해-컨텐츠는-고정-높이를-가져아-합니다)
* [5. 목록 페이지와 상세 페이지에서 동기화 해야 하는 데이터 처리 방안](#5-목록-페이지와-상세-페이지에서-동기화-해야-하는-데이터-처리-방안)
* [6. store에 무한한 데이터를 저장할 수 없습니다.](#6-store에-무한한-데이터를-저장할-수-없습니다)
* [7. 기타 고려사항](#7-기타-고려사항)
* [8. 성능 개선을 위한 Query 최적화](#8-성능-개선을-위한-query-최적화)
<!-- TOC -->

---

# 1. 무한 스크롤
무한 스크롤 기능은 피드처럼 많은 수의 컨텐츠를 보여주기 위해 사용합니다.  
그리고 무한 스크롤 기능을 구현하기 위해서 `페이징 처리`, `스크롤 위치 저장`, `컨텐츠 데이터 실시간 동기화` 등 부가적인 기능들도 고려하면서 구현해야합니다.  
React와 SpringBoot를 활용한 Web View 방식의 애플리케이션에서 무한 스크롤 기능을 구현해보면서 해결했던 문제들과 기획 단계에서 고려되어야 할 부분들에 대해서 정리했습니다.

# 2. 페이지와 컨텐츠 구성 예시
페이지는 `(1) 목록 페이지`, `(2) 상세 페이지`, `(3) 댓글 페이지`로 구성되어 있습니다.  
컨텐츠의 요소는 아래 사진과 같고 `(1) 프로필 영역(프로필 사진, 닉네임)`, `(2) 컨텐츠 영역(제목, 내용, 사진)`, `(3) 소셜 영역(좋아요 수, 댓글 수, 조회 수, 작성 시간`으로 구성되어 있다고 가정합니다.  
소셜 영역에 존재하는 컨텐츠는 각 페이지에서 생성/수정/삭제 될 수 있으며 이 정보는 페이지 전체 새로고침 없이 실시간으로 반영되어야 합니다.  
<img width="775" alt="Image" src="https://github.com/justdoanything/archive/blob/main/images/%EB%AC%B4%ED%95%9C%20%EC%8A%A4%ED%81%AC%EB%A1%A4%20%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD-1.png?raw=true" />  

# 3. 페이징과 정렬 기준
무한 스크롤에서 페이징 처리와 정렬을 같이 구현했을 때 고려해야할 사항이 있습니다.  
피드와 같이 실시간으로 생성되는 데이터를 페이징 처리할 땐 첫번째 컨텐츠의 기준이 없으면 데이터가 중복해서 나타날 수 있습니다.  
예를들어 최신순으로 데이터를 노출할 때 N번째 페이지와 N+1번째 페이지를 호출하는 사이에 K개의 신규 컨텐츠가 등록됐다면 N+1번째 페이지에서는 K개 만큼의 데이터가 중복해서 노출될 수 있습니다.  
<img width="1490" alt="Image" src="https://github.com/justdoanything/archive/blob/main/images/%EB%AC%B4%ED%95%9C%20%EC%8A%A4%ED%81%AC%EB%A1%A4%20%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD-2.png?raw=true" />  

따라서 2번째 페이지부터는 첫번째 페이지의 첫번째 컨텐츠의 id 값이나 작성 시간 등을 기준으로 다음 페이지 데이터를 조회해야 합니다.  
즉, 이러한 중복 데이터를 방지하기 위해서 페이징 처리를 할 때 `정렬 기준`을 정해야 합니다.  
첫번째 페이지의 첫번째 컨텐츠의 id 값을 활용한다면 다음 페이지의 데이터를 조회할 때 첫번째 페이지의 첫번째 컨텐츠의 id 값보다 작은 id 값을 가진 컨텐츠를 조회하면 됩니다.
그리고 뒤로가기로 페이지로 돌아왔을 때, 페이지를 새로고침 했을 때 등 첫번째 컨텐츠 id를 초기화해주는 로직도 신경써서 구현해줘야 합니다.

그리고 `최신순`, `오래된 순`과 같은 기간을 기준으로 하는 정렬은 첫번째 컨텐츠의 id 값을 기준으로 정해서 사용할 수 있지만 `인기순`, `댓글 많은 순`과 같은 정렬은 데이터의 순서ㅏ 실시간으로 바뀔 수 있기 때문에 기준을 잡을 수 없습니다.  
따라서 실시간 데이터를 무한 스크롤로 구현할 때 `인가순`, `댓글 많은 순`과 같은 정렬은 구현할 수 없는 점을 기획 단계에서 고려해야 합니다.  
만약 `인가순`, `댓글 많은 순`과 같은 정렬을 구현하고 싶다면 특정 시간 범위에 해당하는 데이터로 결과물을 따로 저장하고 이를 조회하는 방식으로 구현해야 합니다.

- (1) Paging 관련 Request Parameter  
  <img width="1490" alt="Image" src="https://github.com/justdoanything/archive/blob/main/images/%EB%AC%B4%ED%95%9C%20%EC%8A%A4%ED%81%AC%EB%A1%A4%20%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD-3.png?raw=true" /> 
  
- (2) firstItemId를 적용한 Query  
  ```sql
  SELECT ...
  FROM ...
  WHERE ...
      <if test="firstItemId != null and firstItemId > 0">
        <if test="orderBy != null and 'recent'.equals(orderBy)">
          AND contend_id <![CDATA[<]]> #{firstItemId}
        </if>
        <if test="orderBy != null and 'oldest'.equals(orderBy)">
          AND contend_id <![CDATA[>]]> #{firstItemId}
        </if>
      </if>
  ```

**📌 Check Point**  
✅ 페이징과 정렬을 구현할 때 실시간으로 데이터가 생성/삭제될 수 있음을 고려해서 명확한 `기준`을 정할 수 있는 정렬만 구현해야 합니다.

# 4. 스크롤 위치 계산을 위해 컨텐츠는 고정 높이를 가져아 합니다.
무한 스크롤을 구현한 목록 페이지에서 상세 페이지로 갔다가 뒤로가기 등으로 돌아왔을 때 `기존에 가져왔던 컨텐츠`와 `스크롤 위치`는 유지되어야 합니다.

그리고 목록 페이지에서 컨텐츠는 store에서 관리되며 컨텐츠의 내용이 수정되거나 삭제될 수 있기 때문에 스크롤의 위치는 여러 상황에 따라 임의로 조정해줘야 합니다.
이 때 컨텐츠의 높이가 내용의 길이나 사진 유무에 따라 가변적이라면 컨텐츠의 높이를 알기 어렵기 때문에 스크롤 위치 조정이 많이 어러워집니다.

일정한 규칙에 따라 광고나 배너 같은 추가 요소가 중간에 들어가 있다면 스크롤 위치 계산은 더 어려워집니다.

따라서 상황에 따라 스크롤 위치를 정확하게 계산하고 수정하기 위해선 컨텐츠의 요소는 모두 고정 높이를 가질 수 있도록 설계하는 것이 좋습니다.

**📌 Check Point**  
✅ 상황에 따라 정확한 스크롤 위치를 조작할 수 있도록 컨텐츠 및 추가 요소의 높이는 고정적으로 설계해야 합니다.  
✅ 많은 컨텐츠 데이터를 가져온 상태에서 목록 페이지를 다시 렌더링할 때 컨텐츠가 다 렌더링되기 전에 스크롤이 이동될 수 있기 때문에 정확한 스크롤 위치를 계산하고 이동시키는 부분은 중요합니다.

# 5. 목록 페이지와 상세 페이지에서 동기화 해야 하는 데이터 처리 방안
목록 페이지는 `기존에 가져왔던 컨텐츠`와 `스크롤 위치`는 유지되어야 하기 때문에 데이터를 가져올 때마다 store에 데이터를 저장하고 관리합니다.
그리고 상세 페이지는 페이지가 로드될 때 데이터를 `실시간`으로 가져와서 보여줍니다.

이러한 차이 때문에 주로 `소셜 데이터`(좋아요 여부, 좋아요 수, 댓글 수, 조회 수)가 목록 페이지와 상세 페이지에서 실시간으로 동기화 해줘야 하는 데이터 입니다.

좋아요 기능을 예로 들면 목록 페이지에서 좋아요를 누르면 좋아요 여부와 좋아요 수가 변경됩니다. 목록 페이지에 있는 데이터는 store에 있기 때문에 store 안에서 해당 컨텐츠 데이터를 찾아 좋아요 여부와 수를 수정해줘야 합니다.

그리고 상세 페이지로 이동했을 때 상세 페이지는 데이터를 실시간으로 가져오기 때문에 좋아요 여부와 수는 정상적으로 표시됩니다.

하지만 상세 페이지에서 좋아요를 누르고 목록 페이지로 돌아왔을 때 목록 페이지에서는 좋아요 여부와 수가 변경되지 않습니다.
따라서 상세 페이지에서 좋아요에 대한 이벤트를 처리할 때 store에 있는 목록 페이지 데이터를 찾아서 함께 수정해줘야 합니다.

이는 상세 페이지 뿐만 아니라 댓글 팝업 등에서도 `좋아요 등록/취소`, `댓글 등록/수정/삭제`, `조회수 증가` 등 특정 이벤트가 발생했을 때 목록 페이지에서도 데이터가 동일하게 표시될 수 있도록 store에 있는 데이터도 반드시 수정해줘야 합니다. 또한 `컨텐츠 내용 수정/삭제`도 처리해줘야 합니다.

추가적으로 좋아요 수, 댓글 수, 조회수는 실시간으로 변하는 데이터입니다. 만약 좋아요 이벤트를 처리할 때 store에 있는 컨텐츠 데이터의 좋아요 수를 +1 처리만 했다면 목록 페이지에서 상세 페이지로 다시 갔을 때 좋아요 수가 다를 수 있습니다.

왜냐하면 그 사이에 다른 유저가 좋아요를 눌렀을 때 목록 페이지에선 +1만 되지만 상세 페이지에선 실시간으로 데이터를 실시간으로 가져오기 때문에 +2가 된 값이 보이기 때문입니다.

그렇다고해서 store에 있는 데이터를 수정할 때마다 서버로부터 데이터를 받아 처리한다면 속도나 성능 문제가 발생할 수도 있습니다.

따라서 위와 같은 문제가 있음을 고려해서 데이터 차이를 무시한채 +-1 처리만할지, 속도나 성능에 이슈가 없어서 실시간으로 데이터를 받아서 수정할지 의사결정을 미리 해야 합니다. 그리고 개발자는 이를 고려하여 데이터 구조와 store를 설계하고 기능 구현할 때 고려해야 합니다.

이 부분은 실제로 개발했을 때 처리해줘야 하는 이벤트 형태도 많고 적용해야 하는 페이지도 많아서 어렵고 복잡했던 기능입니다.
반드시 사전에 해당 기능을 구현하기 위해 고려해야할 사항과 제약사항을 인지하고 설계하면 좋을 것 같습니다.

**📌 Check Point**  
✅ 실시간으로 변할 수 있는 데이터를 목록 페이지, 상세 페이지 및 다른 페이지에서 실시간으로 동기화될 수 있도록 store에 있는 데이터를 수정해줘야 합니다.  
✅ store에 있는 데이터를 수정할 때 +-1 처리만 할지 서버로부터 실시간으로 데이터를 받아서 컨텐츠를 수정할지 사전에 고려해서 설계해야 합니다.  
✅ 컨텐츠 중간에 추가 요소들이 들어갈 경우, store에 컨텐츠를 저장할 때 중간요소도 다 같이 포함해서 저장하는 것이 좋습니다. 컨텐츠와 추가 요소를 따로 관리하면 목록 페이지에서 기존 데이터를 다시 렌더링할 때 로직이 다소 복잡해지기 때문입니다.  
✅ 기존 프로젝트에서는 URL 기준으로 store를 관리했었는데 하나의 목록 페이지 안에서 여러 개의 탭으로 나눠서 무한 스크롤을 구현하고 store 데이터와 스크롤 위치를 관리해야하는데 어려움이 있었습니다. 요구사항을 충분히 이해하고 고려해서 store를 설계하고 구현해야 합니다.  
✅ 이 문제는 목록 페이지와 상세 페이지만의 문제는 아닙니다. 댓글을 팝업창으로 구현했다면 상세 페이지에서 보이는 댓글 데이터도 조작해줘야 하고 목록 페이지에서 보이는 댓글 데이터를 조작해줘야 합니다.  

# 6. store에 무한한 데이터를 저장할 수 없습니다.
사용자가 페이지를 내릴 때마다 가져온 데이터는 store에 저장됩니다. 하지만 컨텐츠가 무한하다면 모든 데이터가 store에 계속 저장되고 유지될 수 없습니다.

특히 컨텐츠가 사진이나 동영상을 포함하고 있다면 store에 저장되는 용량도 커지기 때문에 성능에도 영향을 미칠 수 있습니다.

이를 해결하기 위해선 크게 2가지 방법을 사용할 수 있습니다.

1. store에 저장되는 데이터의 수를 제한합니다.  
   store에 저장된 데이터가 일정한 수를 넘으면 가장 오래된 데이터를 지우고 새로운 데이터를 추가합니다. 예를들어 사이즈를 200으로 정했다면 201~210번째 데이터를 추가할 때 1~10번째 데이터를 삭제합니다.  
   이렇게하면 사용자가 어느 순간에 스크롤을 최상단으로 올렸을 때 처음 봤던 컨텐츠를 볼 수 없습니다.  

2. onScrollTop과 onScrollBottom을 모두 구현합니다.  
   store에는 일정한 데이터의 수만 저장하고 있고 스크롤의 onTop과 onBottom 이벤트를 감지해서 이전 데이터와 이후 데이터를 적절하게 가져오고 store에 있는 데이터를 조정해줍니다.  
   이렇게하면 사용자가 스크롤을 최상단으로 올렸을 때 처음 봤던 컨텐츠를 볼 수 있지만 이전 데이터를 새로 가져와야 하기 때문에 로딩이 발생할 수 있고 이전 데이터를 가져오면서 최근 데이터를 지우기 때문에 스크롤을 다시 내린다면 로딩이 발생할 수 있습니다.  
   따라서 가장 최근에 호출한 페이지 번호 를 기억하고 onScrollTop과 onScrollBottom을 처리할 때 Paging size와 num을 적절하게 조정해야 합니다.  

**📌 Check Point**  
✅ 무한 스크롤에 사용되는 컨텐츠는 가능한한 최대한 가볍게 설계애햐 합니다.  
✅ onScrollTop과 onScrollBottom을 모두 구현하면 난이도가 많이 상승하고 최상단과 최하단에 도달했는지 여부를 sticky component를 포함해서 구분을 잘 해줘야 합니다.  
✅ store에 있는 데이터가 사라질 수 있기 때문에 store에 있는 데이터를 수정할 때 고려해야 합니다.  
✅ store에 있는 데이터가 많을 경우 상세 페이지에서 목록 페이지로 돌아올 때 컨텐츠가 로딩되는 동안 흰 화면이 나오는 이슈가 있었습니다. 이 부분을 방지하기 위해서 스켈레톤이나 로딩 페이지를 적절하게 구현해야 합니다. 또는 InView를 사용해서 컨텐츠를 숨기는 방법도 있습니다.  

# 7. 기타 고려사항
- 공통 컴포넌트를 설계할 때 외부에서 데이터를 제어할 수 있도록 설계하자. (with 댓글 컴포넌트)
  - 공통 컴포넌트를 만들 때 최하단 컴포넌트는 만들어진 데이터를 렌더링하기만 하고 데이터를 재조회하는 등 이벤트 제어는 상단 컴포넌트에서 컨트롤하도록 설계해야 한다.
  - 공통 컴포넌트를 사용하는 외부 컴포넌트에서 데이터 재조회 시점을 정하거나 댓글처럼 트래픽을 줄이기 위해 생성/수정/삭제 시 서버를 거치지 않고 가져온 데이터를 제어할 수 있도록 설계할 수도 있다.
- 테스트 코드가 없다면 테스트 케이스를 최소한으로라도 작성하자.
  - 프로젝트 후반부로 갈수록 컴포넌트가 무거워지고 복잡한 로직들이 많아집니다. 요구사항과 기획이 바뀌고 여러 SE가 돌아가면서 같은 코드를 개발하고 리팩토링하고 버그수정을 하는 상황에서 사이드이펙트가 발생할 확률도 같이 높아집니다.
  - 개발자가 각 페이지를 개발하고 MR을 올리기 전에 테스트할 때 최소한의 케이스를 wiki에 작성하고 다른 개발자가 해당 페이지를 수정할 때 재수행할 수 있도록 하면 좋을 것 같습니다.
  - 기획서가 모든 히스토리를 반영할 수 없고 개발자가 코드를 수정할 때 기존 이력을 모두 고려할 수 없기 때문에 테스트 케이스를 작성하면 좋을 것 같습니다.
  - 기획서 및 요구사항이 바뀔 경우 그에 대한 테스트 케이스도 수정하고 프로젝트 후반에서 사이드 이펙트를 줄일 수 있는 방법을 찾으면 좋을 것 같습니다.
  - 각 페이지는 서버에서 에러 응답이 왔을 경우, 빈 데이터가 왔을 경우 등 에러 케이스에 대한 처리를 해야 합니다.
- 썸네일 생성과 처리
  - 프로젝트에서 썸네일 이미지 생성을 AWS Lambda를 통해서 처리했었습니다. S3 특정 경로에 이미지나 동영상이 업로드됐을 때 Lambda를 통해 thumbnail 경로에 썸네일 이미지를 저장했습니다.
  - 따라서 썸네일 파일이 생성되기까지 시간 차이가 존재했었고 목록 페이지에서 썸네일 파일을 사용했기 때문에 게시글 등록 후 목록으로 바로 넘어가면 이미지가 정상적으로 노출되지 않을 수 있었습니다.
  - 이를 해결하기 위해서 이미지 컴포넌트 내부적으로 썸네일 경로에서 파일을 가져오고 에러가 발생하면 원본 경로에서 파일을 가져오도록 처리했습니다.
  - 문제는 동영상 썸네일이었는데 동영상은 썸네일 파일이 없으면 이미지 자체를 노출할 수 없었기 때문에 디폴트 이미지는 노출하는 방식으로 처리했습니다.

# 8. 성능 개선을 위한 Query 최적화
- MyBatis + MySQL을 사용할 때 비교하는 타입이 다를 경우 반드시 `CAST`를 사용해야 합니다.
  ```sql
    SELECT ...
    FROM ...
    WHERE reference_value1 = CAST(community_id AS CHAR)
  ```
- Admin 화면처럼 검색 조건이 다양하고 검색되는 데이터의 양이 많아서 성능을 조정해야 할 때 Admin 화면처럼 상황에 따라 여러 조건이 있는 경우 조건에 따라 FROM, WHERE 절을 알맞게 조정해주고 검색 쿼리가 복잡한 경우 검색할 데이터의 id 값을 먼저 검색하고 두번째 쿼리에서 `ORDER BY FIELD`를 사용할 수 있습니다.
  ```sql
    SELECT c.community_id AS communityId
    FROM community c
       <if test="bbsName != null and bbsName != ''">
         LEFT JOIN bbs b ON c.bbs_id = b.bbs_id
       </if>
    <where>
       <if test="bbsName != null and bbsName != ''">
         AND b.bbs_name = #{bbsName}
       </if>
    </where> 
  ```
  ```sql
    SELECT c.community_id AS communityId
       <if test="bbsName != null and bbsName != ''">
         b.bbs_name AS bbsName
       </if>
    FROM community c
       <if test="bbsName != null and bbsName != ''">
         LEFT JOIN bbs b ON c.bbs_id = b.bbs_id
       </if>
    WHERE c.community_id IN
          <foreach collection="communityIds" item="id" open="(" separator="," close=")">
             #{id}
          </foreach>
     ORDER BY FIELD(c.community_id,
          <foreach collection="communityIds" item="id" separator=",">
             #{id}
          </foreach>
          )
  ```